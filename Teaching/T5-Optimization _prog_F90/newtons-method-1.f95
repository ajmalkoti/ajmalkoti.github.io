!Newton's method
!ALGO: THE UPDATE SHOULD BE DONE IN THE FOLLOWING MANNER
!		Xn+1= Xn + (Hn^-1)*Gn  	where Hn^-1 is inverse of hessian matrix,and  Gn is gradient
!FUNCTIONS/SUBROUTINE LIST:
! F; FX; FY; FXX; FYY; FXY; FYX; GRADIENT; HESSIAN,STEP

PROGRAM NEWTON_METHOD
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))		:: X,Y,F0,F1,A(2,1),ALPHA(2,1),EPS
REAL (SELECTED_REAL_KIND(15,307)), PARAMETER ::  h=10E-6

PRINT *, 'ENTER THE INTIAL GUESS FOR COORDINATE X AND Y: '
READ*, X,Y

A(1,1)=X
A(2,1)=Y
F0=F(X,Y)
EPS=EPSILON(1.)
PRINT *, 'EPSILON NO IS=' , EPS

OPEN(10, FILE="DATA5_13.DAT")
DO 
 PRINT *, "X,Y ARE : ", A(1,1), A(2,1)
 PRINT *, "Value of F0  : ",F0
 WRITE (10,*) A, F0 
 
 CALL STEP(ALPHA, A(1,1), A(2,1))
 A=A-ALPHA
 F1=F(A(1,1),A(2,1))
 IF (ABS(F0-F1)<EPS) EXIT
 F0=F1
END DO

PRINT *, 'THE FINAL SOLUTION IS : ', A
PRINT *, "final Value of F  : ",F1
WRITE(10,*) A, F0
CLOSE(10) 
!****************************************************************************

CONTAINS


FUNCTION F(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307)) 	:: X,Y,F,PI
!F=X**2 + Y**2							!THE D'JONG-FUNCTION IS DEFINED HERE
!F=100*((Y-X**2)**2) + ((1-X)**2)		!THE ROSENBROCK-FUNCTION IS DEFINED HERE
PI=4*ATAN(1.)							!THE RASGRIN-FUNCTION IS DEFINED HERE
F=10+(X**2-10*COS(2*PI*X)) + (Y**2 + 10*COS(2*PI*Y))
END FUNCTION

!CALCULATING THE FIRST DERIVATIVE OF F WRT X
FUNCTION FX(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FX
FX=  (F(X+h,Y)- F(X-h,Y)) / (2*h)
END FUNCTION FX

!CALCULATING THE FIRST DERIVATIVE OF F WRT Y
FUNCTION FY(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FY
FY=  (F(X,Y+h)- F(X,Y-h)) / (2*h)
END FUNCTION FY

!CALCULATING THE SECOND DERIVATIVE OF FX WRT X
FUNCTION FXX(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FXX
FXX=  (FX(X+h,Y)- FX(X-h,Y)) / (2*h)
END FUNCTION FXX

!CALCULATING THE SECOND DERIVATIVE OF FY WRT Y
FUNCTION FYY(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FYY
FYY= (FY(X,Y+h)- FY(X,Y-h)) / (2*h)
END FUNCTION FYY

!CALCULATING THE SECOND DERIVATIVE OF FY WRT X
FUNCTION FYX(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FYX
FYX=  (FY(X+h,Y)- FY(X-h,Y)) / (2*h)
END FUNCTION FYX

!CALCULATING THE SECOND DERIVATIVE OF FX WRT Y
FUNCTION FXY(X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,FXY
FXY=  (FX(X,Y+h)- FX(X,Y-h)) / (2*h)
END FUNCTION FXY

!FUNC CALCULATING STEP SIZE
SUBROUTINE STEP(ALPHA,X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307))	:: X,Y,H(2,2),G(2,1),det,inv_H(2,2),ALPHA(2,1)
CALL GRADIENT(G,X,Y)
CALL HESSIAN(H,X,Y)
!PRINT *, 'HESSIAN=',H
det=H(1,1)*H(2,2)-H(2,1)*H(1,2)
inv_H(1,1)= H(2,2)/det
inv_H(1,2)=-H(1,2)/det
inv_H(2,1)=-H(2,1)/det
inv_H(2,2)=H(1,1)/det

ALPHA=MATMUL(inv_H,G)
!PRINT *,'ALPHA=',ALPHA
END SUBROUTINE STEP

!CALCULATE THE GRADIENT
SUBROUTINE GRADIENT(G,X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307)), INTENT(OUT) :: G(2,1)
REAL (SELECTED_REAL_KIND(15,307)), INTENT (IN) :: X,Y
G(1,1)= FX(X,Y)
G(2,1)= FY(X,Y)
END SUBROUTINE GRADIENT

!CALCULATING THE HESSIAN METRIX
SUBROUTINE HESSIAN(H,X,Y)
IMPLICIT NONE
REAL (SELECTED_REAL_KIND(15,307)), INTENT(OUT)::H(2,2)
REAL (SELECTED_REAL_KIND(15,307)), INTENT(IN) :: X,Y
H(1,1)=FXX(X,Y)
H(1,2)=FXY(X,Y)
H(2,1)=FYX(X,Y)
H(2,2)=FYY(X,Y)
END SUBROUTINE HESSIAN

END PROGRAM NEWTON_METHOD
